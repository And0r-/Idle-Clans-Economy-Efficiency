════════════════════════════════════════════════════════════════════════
                         PROJECT SUMMARY
════════════════════════════════════════════════════════════════════════

Projekt: Idle-Clans-Economy-Efficiency
Pfad: /home/and0r/projects/Idle-Clans-Economy-Efficiency
Erstellt: 2025-10-10 23:07:14
Anzahl Dateien: 43

════════════════════════════════════════════════════════════════════════
                         INHALTSVERZEICHNIS
════════════════════════════════════════════════════════════════════════

  • .gitignore
  • README.md
  • data/activities.json
  • data/xp_table.json
  • idleclans/__init__.py
  • idleclans/admin.py
  • idleclans/apps.py
  • idleclans/migrations/__init__.py
  • idleclans/models.py
  • idleclans/static/idleclans/base.js
  • idleclans/tests.py
  • idleclans/urls.py
  • idleclans/views.py
  • main.py
  • manage.py
  • mysite/__init__.py
  • mysite/asgi.py
  • mysite/settings.py
  • mysite/urls.py
  • mysite/wsgi.py
  • polls/__init__.py
  • polls/admin.py
  • polls/apps.py
  • polls/migrations/0001_initial.py
  • polls/migrations/__init__.py
  • polls/models.py
  • polls/tests.py
  • polls/urls.py
  • polls/views.py
  • requirements.txt
  • services/__init__.py
  • services/api_client.py
  • services/chat_service.py
  • services/clan_service.py
  • services/item_service.py
  • services/leaderboard_service.py
  • services/player_market_service.py
  • services/player_service.py
  • services/task_service.py
  • utils/__init__.py
  • utils/ascii_ui.py
  • utils/util.py
  • utils/xp.py


════════════════════════════════════════════════════════════════════════
FILE: .gitignore
────────────────────────────────────────────────────────────────────────

dev

# venv
venv

# Caches
__pycache__
*.pyc


════════════════════════════════════════════════════════════════════════
FILE: README.md
────────────────────────────────────────────────────────────────────────

<!-- template by: https://github.com/othneildrew/Best-README-Template/blob/main/README.md77 -->
<a id="readme-top"></a>



[![Contributors][contributors-shield]][contributors-url]
[![Forks][forks-shield]][forks-url]
[![Stargazers][stars-shield]][stars-url]
[![Issues][issues-shield]][issues-url]
[![LinkedIn][linkedin-shield]][linkedin-url]
<!-- [![MIT License][license-shield]][license-url] -->



<!-- PROJECT LOGO -->
<br />
<div align="center">
  <a href="https://github.com/Lyon-K/Idle-Clans-Economy-Efficiency">
  <!-- logo from https://www.google.com/url?sa=i&url=https%3A%2F%2Fpngtree.com%2Fso%2Feconomy-logo&psig=AOvVaw0pe59QcMwlhPxPienJa3eu&ust=1723665650616000&source=images&cd=vfe&opi=89978449&ved=0CBQQjRxqFwoTCNClwP_i8ocDFQAAAAAdAAAAABAE -->
    <img src="images/logo.png" alt="Logo" width="80" height="80">
  </a>

  <h3 align="center">Idle Clans Profit Optimizer</h3>

  <p align="center">
    A real-time guide to the most gold efficient item to farm!
    <br />
    <!-- <a href="https://github.com/othneildrew/Best-README-Template">View Demo</a> -->
    <a href=""><s>View Demo</s></a>
    ·
    <a href="https://github.com/Lyon-K/Idle-Clans-Economy-Efficiency/issues/new?labels=bug&template=bug-report---.md">Report Bug</a>
    ·
    <a href="https://github.com/Lyon-K/Idle-Clans-Economy-Efficiency/issues/new?labels=enhancement&template=feature-request---.md">Request Feature</a>
  </p>
</div>



<!-- TABLE OF CONTENTS -->
<details>
  <summary>Table of Contents</summary>
  <ol>
    <li>
      <a href="#about-the-project">About The Project</a>
      <ul>
        <li><a href="#built-with">Built With</a></li>
      </ul>
    </li>
    <li>
      <a href="#getting-started">Getting Started</a>
      <ul>
        <li><a href="#prerequisites">Prerequisites</a></li>
        <li><a href="#installation">Installation</a></li>
      </ul>
    </li>
    <li><a href="#usage">Usage</a></li>
    <!-- <li><a href="#roadmap">Roadmap</a></li>
    <li><a href="#contributing">Contributing</a></li>
    <li><a href="#license">License</a></li>
    <li><a href="#contact">Contact</a></li> -->
    <li><a href="#acknowledgments">Acknowledgments</a></li>
  </ol>
</details>



<!-- ABOUT THE PROJECT -->
## About The Project

<!-- [![Product Name Screen Shot][product-screenshot]](https://example.com) -->

This program is designed for players of **Idle Clans** to optimize their in-game strategy by identifying the most profitable items to farm and sell on the player market. By analyzing the current market economy and taking into account the user's account details, the program calculates the highest gold per time (G/T) ratio obtainable, ensuring the most efficient farming strategy.

Key features of the program include:
- **Account Integration**: The program uses player-specific data, including skills and levels, to filter out items that are beyond the user's ability to farm, focusing only on what is feasible and profitable.
- **Market Analysis**: It tracks item prices over multiple days to identify trends, helping players adjust their strategy based on evolving market conditions.
- **Efficiency Optimization**: By calculating the G/T ratio, the program suggests the best farming strategy tailored to the user's capabilities, maximizing earnings with minimal time.

Whether you're a casual player or a competitive grinder, this tool provides the insights you need to dominate the Idle Clans economy.

<p align="right">(<a href="#readme-top">back to top</a>)</p>



### Built With

This section lists the major frameworks and libraries used to bootstrap the project. Add-ons and plugins are mentioned in the acknowledgements section.

* [![Python][Python.org]][Python-url]
* [![Idle Clans API][IdleClans.com]][IdleClans-url]

<p align="right">(<a href="#readme-top">back to top</a>)</p>



<!-- GETTING STARTED -->
## Getting Started

This is an example of how you may give instructions on setting up your project locally.
To get a local copy up and running follow these simple example steps.

### Prerequisites

To set up and run this project, you need to have Python installed. Below are the instructions for installing Python and pip (the Python package installer):

* **Python** (version 3.7 or higher)
  - **Windows**:
    1. Download the installer from [python.org](https://www.python.org/downloads/).
    2. Run the installer and ensure you check the box that says "Add Python to PATH".
    3. Follow the prompts to complete the installation.
  - **macOS**:
    1. Open Terminal.
    2. Install Python using Homebrew:
       ```sh
       brew install python
       ```
  - **Linux**:
    1. Open Terminal.
    2. Install Python using your package manager:
       ```sh
       sudo apt update
       sudo apt install python3
       ```

* **pip** (Python package installer)
  - **Usually installed with Python**, but you can update it using:
    ```sh
    python -m pip install --upgrade pip
    ```

<p align="right">(<a href="#readme-top">back to top</a>)</p>

### Installation

This guide will help you install and set up the Python project for Idle Clans Profit Optimizer, a tool designed to determine the most profitable items to farm and sell in the Idle Clans game.

1. **Clone the repository**:
   ```sh
   git clone https://github.com/Lyon-K/Idle-Clans-Economy-Efficiency.git
   ```
2. **Navigate to the project directory**:
   ```sh
   cd repo_name
   ```
3. **Create and activate a virtual environment**:
   ```sh
   python -m venv venv
   source venv/bin/activate  # On Windows use `venv\Scripts\activate`
   ```
<!-- 4. **Install the required Python packages**:
   ```sh
   pip install -r requirements.txt
   ``` -->

<p align="right">(<a href="#readme-top">back to top</a>)</p>



<!-- USAGE EXAMPLES -->
## Usage

   Run the program and it will calculate the best items for efficiency

   ```sh
   python main.py
   ```

<p align="right">(<a href="#readme-top">back to top</a>)</p>



<!-- ACKNOWLEDGMENTS -->
## Acknowledgments

I would like to acknowledge the following tools and libraries that made this project possible!

* [Best README Template](https://github.com/othneildrew/Best-README-Template)
* [Choose an Open Source License](https://choosealicense.com)
<!-- * [GitHub Pages](https://pages.github.com) -->

<p align="right">(<a href="#readme-top">back to top</a>)</p>



<!-- MARKDOWN LINKS & IMAGES -->
<!-- https://www.markdownguide.org/basic-syntax/#reference-style-links -->
[contributors-shield]: https://img.shields.io/github/contributors/Lyon-K/Idle-Clans-Economy-Efficiency.svg?style=for-the-badge
[contributors-url]: https://github.com/Lyon-K/Idle-Clans-Economy-Efficiency/graphs/contributors
[forks-shield]: https://img.shields.io/github/forks/Lyon-K/Idle-Clans-Economy-Efficiency.svg?style=for-the-badge
[forks-url]: https://github.com/Lyon-K/Idle-Clans-Economy-Efficiency/network/members
[stars-shield]: https://img.shields.io/github/stars/Lyon-K/Idle-Clans-Economy-Efficiency.svg?style=for-the-badge
[stars-url]: https://github.com/Lyon-K/Idle-Clans-Economy-Efficiency/stargazers
[issues-shield]: https://img.shields.io/github/issues/Lyon-K/Idle-Clans-Economy-Efficiency.svg?style=for-the-badge
[issues-url]: https://github.com/Lyon-K/Idle-Clans-Economy-Efficiency/issues
[license-shield]: https://img.shields.io/github/license/Lyon-K/Idle-Clans-Economy-Efficiency.svg?style=for-the-badge
[license-url]: https://github.com/Lyon-K/Idle-Clans-Economy-Efficiency/blob/master/LICENSE.txt
[linkedin-shield]: https://img.shields.io/badge/-LinkedIn-black.svg?style=for-the-badge&logo=linkedin&colorB=555
[linkedin-url]: https://linkedin.com/in/lyonk

[Python.org]: https://img.shields.io/badge/Python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54
[Python-url]: https://www.python.org/
[IdleClans.com]: https://img.shields.io/badge/Idle%20Clans%20API-282C34?style=for-the-badge
[IdleClans-url]: https://query.idleclans.com/api-docs/index.html


════════════════════════════════════════════════════════════════════════
FILE: data/activities.json
────────────────────────────────────────────────────────────────────────

[Binärdatei - Inhalt nicht angezeigt]


════════════════════════════════════════════════════════════════════════
FILE: data/xp_table.json
────────────────────────────────────────────────────────────────────────

[Binärdatei - Inhalt nicht angezeigt]


════════════════════════════════════════════════════════════════════════
FILE: idleclans/__init__.py
────────────────────────────────────────────────────────────────────────

[Binärdatei - Inhalt nicht angezeigt]


════════════════════════════════════════════════════════════════════════
FILE: idleclans/admin.py
────────────────────────────────────────────────────────────────────────

from django.contrib import admin

# Register your models here.


════════════════════════════════════════════════════════════════════════
FILE: idleclans/apps.py
────────────────────────────────────────────────────────────────────────

from django.apps import AppConfig


class IdleclansConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "idleclans"


════════════════════════════════════════════════════════════════════════
FILE: idleclans/migrations/__init__.py
────────────────────────────────────────────────────────────────────────

[Binärdatei - Inhalt nicht angezeigt]


════════════════════════════════════════════════════════════════════════
FILE: idleclans/models.py
────────────────────────────────────────────────────────────────────────

from django.db import models

# Create your models here.

class Item(models.Model):
    ItemId = models.IntegerField(default=-1)
    Name = models.CharField(max_length=50)
    BaseValue = models.IntegerField(default=-1)
    CanNotBeSoldToGameShop = models.BooleanField(default=False)
    CanNotBeTraded = models.BooleanField(default=False)

════════════════════════════════════════════════════════════════════════
FILE: idleclans/static/idleclans/base.js
────────────────────────────────────────────────────────────────────────

[Binärdatei - Inhalt nicht angezeigt]


════════════════════════════════════════════════════════════════════════
FILE: idleclans/tests.py
────────────────────────────────────────────────────────────────────────

from django.test import TestCase

# Create your tests here.


════════════════════════════════════════════════════════════════════════
FILE: idleclans/urls.py
────────────────────────────────────────────────────────────────────────

from django.urls import path

from . import views

urlpatterns = [
    path("", views.index, name='index'),
]


════════════════════════════════════════════════════════════════════════
FILE: idleclans/views.py
────────────────────────────────────────────────────────────────────────

from django.shortcuts import render
from django.http import HttpResponse

def index(request):
    # return HttpResponse("Hello world, this is the Idle Clans tracker!")
    return render(request, 'idleclans/index.html')

def gold_efficiency(request):
    return render(request, "gold_efficiency.html")

════════════════════════════════════════════════════════════════════════
FILE: main.py
────────────────────────────────────────────────────────────────────────

import json
import time
from services import (
    APIClient,
    ChatService,
    ClanService,
    LeaderboardService,
    PlayerService,
    PlayerMarketService,
    ItemService,
    TaskService,
)
from utils import AsciiUI


# Initialize API Client
api_client = APIClient()
# Initialize API DataServices
chat_service = ChatService(api_client)
clan_service = ClanService(api_client)
leaderboard_service = LeaderboardService(api_client)
player_service = PlayerService(api_client)
player_market_service = PlayerMarketService(api_client)
# Initialize local DataServices
item_service = ItemService()
task_service = TaskService(item_service)
ascii_ui = AsciiUI()

latest_prices = None
character = None


def fetchPrices():
    global latest_prices
    latest_prices = player_market_service.get_items_prices_latest(
        include_average_price=True
    )


def calculateEfficiency(task, character={"xp_multiplier": 1, "time_multiplier": 1}):
    # Todo: Calculate effective time from time multiplier
    # effective_time = character["time_multiplier"] * task.base_time
    effective_time = task.base_time
    # Calculate xp/time
    task.xp_efficiency = character["xp_multiplier"] * task.exp_reward / effective_time
    task.gold_efficiency_calculation_time = time.time()

    # Cauculate gold/time
    if latest_prices == None:
        return print("Latest market prices are unavailable for gold calculation")
    base_gold_efficiency = task.item_reward.base_value / effective_time
    market_gold_efficiency = (
        latest_prices_get_item(latest_prices, task.item_reward.id)["highestBuyPrice"]
        / effective_time
    )
    if base_gold_efficiency >= market_gold_efficiency:
        task.gold_efficiency = base_gold_efficiency
        task.sold_as_base_price = True
    else:
        task.gold_efficiency = market_gold_efficiency
    task.xp_efficiency_calculation_time = time.time()
    latest_prices.sort(reverse=True, key=lambda item: item["lowestSellPrice"])
    print(json.dumps(latest_prices[:10], indent=4))


def latest_prices_get_item(latest_prices, id):
    for item in latest_prices:
        if item["itemId"] == id:
            return item


if __name__ == "__main__":
    print("PROGRAM START")
    fetchPrices()
    for category in task_service.categories:
        for task in category.tasks:
            calculateEfficiency(task)

    # menuSelection = -1
    # while menuSelection != "0":
    #     print(ascii_ui.menu())
    #     usr = input("Please choose an option: ")
    #     while usr < "0" or usr > str(4):
    #         usr = input("Please choose an option: ")
    #     if menuSelection == "1":
    #         print(ascii_ui.calculate_gold_efficiency())
    #     elif menuSelection == "2":
    #         print(ascii_ui.market_search())
    #     elif menuSelection == "3":
    #         print(ascii_ui.reload_data())
    #     elif menuSelection == "4":
    #         print(ascii_ui.settings())
    #     elif menuSelection == "-1":
    #         print("TEMP:")
    #         print(
    #             json.dumps(
    #                 player_market_service.get_items_prices_history(158),
    #                 # player_service.get_profile("TheMucker"),
    #                 indent=4,
    #             )
    #         )
    print("\nThank you for using Idle Clans Profit Calculator")


════════════════════════════════════════════════════════════════════════
FILE: manage.py
────────────────────────────────────────────────────────────────────────

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "mysite.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()


════════════════════════════════════════════════════════════════════════
FILE: mysite/__init__.py
────────────────────────────────────────────────────────────────────────

[Binärdatei - Inhalt nicht angezeigt]


════════════════════════════════════════════════════════════════════════
FILE: mysite/asgi.py
────────────────────────────────────────────────────────────────────────

"""
ASGI config for mysite project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "mysite.settings")

application = get_asgi_application()


════════════════════════════════════════════════════════════════════════
FILE: mysite/settings.py
────────────────────────────────────────────────────────────────────────

"""
Django settings for mysite project.

Generated by 'django-admin startproject' using Django 5.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure--k9am@h8%16*+bta&z@+%(+!-b)=kexvex-bqg=y_u-5o=@&18"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    "polls.apps.PollsConfig",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "debug_toolbar",
    "idleclans",
    "bootstrap5"
]

MIDDLEWARE = [
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "mysite.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "mysite.wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "America/Los_Angeles"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = "static/"

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

INTERNAL_IPS = [
    # ...
    "127.0.0.1",
    # ...
]

DEBUG_TOOLBAR_PANELS = [
    'debug_toolbar.panels.history.HistoryPanel',
    'debug_toolbar.panels.versions.VersionsPanel',
    'debug_toolbar.panels.timer.TimerPanel',
    'debug_toolbar.panels.settings.SettingsPanel',
    'debug_toolbar.panels.headers.HeadersPanel',
    'debug_toolbar.panels.request.RequestPanel',
    'debug_toolbar.panels.sql.SQLPanel',
    'debug_toolbar.panels.staticfiles.StaticFilesPanel',
    'debug_toolbar.panels.templates.TemplatesPanel',
    'debug_toolbar.panels.alerts.AlertsPanel',
    'debug_toolbar.panels.cache.CachePanel',
    'debug_toolbar.panels.signals.SignalsPanel',
    'debug_toolbar.panels.redirects.RedirectsPanel',
    'debug_toolbar.panels.profiling.ProfilingPanel',
]

════════════════════════════════════════════════════════════════════════
FILE: mysite/urls.py
────────────────────────────────────────────────────────────────────────

"""
URL configuration for mysite project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

from django.contrib import admin
from django.urls import include, path
from debug_toolbar.toolbar import debug_toolbar_urls

urlpatterns = [
    path("", include("idleclans.urls")),
    path("tutorial/polls/", include("polls.urls")),
    path("admin/", admin.site.urls),
] + debug_toolbar_urls()


════════════════════════════════════════════════════════════════════════
FILE: mysite/wsgi.py
────────────────────────────────────────────────────────────────────────

"""
WSGI config for mysite project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "mysite.settings")

application = get_wsgi_application()


════════════════════════════════════════════════════════════════════════
FILE: polls/__init__.py
────────────────────────────────────────────────────────────────────────

[Binärdatei - Inhalt nicht angezeigt]


════════════════════════════════════════════════════════════════════════
FILE: polls/admin.py
────────────────────────────────────────────────────────────────────────

from django.contrib import admin

from .models import Question, Choice


# Register your models here.
class ChoiceInLine(admin.TabularInline):
    model = Choice
    extra = 3


class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None, {"fields": ["question_text"]}),
        ("Date Information", {"fields": ["pub_date"]}),
    ]
    inlines = [ChoiceInLine]
    list_display = ["question_text", "pub_date", "was_published_recently"]
    list_filter = ["pub_date"]
    search_fields = ["question_text"]


admin.site.register(Question, QuestionAdmin)


════════════════════════════════════════════════════════════════════════
FILE: polls/apps.py
────────────────────────────────────────────────────────────────────────

from django.apps import AppConfig


class PollsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "polls"


════════════════════════════════════════════════════════════════════════
FILE: polls/migrations/0001_initial.py
────────────────────────────────────────────────────────────────────────

# Generated by Django 5.1 on 2024-08-17 06:21

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="Question",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("question_text", models.CharField(max_length=200)),
                ("pub_date", models.DateTimeField(verbose_name="date published")),
            ],
        ),
        migrations.CreateModel(
            name="Choice",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("choice_text", models.CharField(max_length=200)),
                ("votes", models.IntegerField(default=0)),
                (
                    "question",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE, to="polls.question"
                    ),
                ),
            ],
        ),
    ]


════════════════════════════════════════════════════════════════════════
FILE: polls/migrations/__init__.py
────────────────────────────────────────────────────────────────────────

[Binärdatei - Inhalt nicht angezeigt]


════════════════════════════════════════════════════════════════════════
FILE: polls/models.py
────────────────────────────────────────────────────────────────────────

import datetime

from django.db import models
from django.utils import timezone
from django.contrib import admin

# Create your models here.


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")

    def __str__(self):
        return self.question_text

    @admin.display(
        boolean=True,
        ordering="pub_date",
        description="Published recently",
    )
    def was_published_recently(self):
        now = timezone.now()
        return now - datetime.timedelta(days=1) <= self.pub_date <= now


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    def __str__(self):
        return self.choice_text


════════════════════════════════════════════════════════════════════════
FILE: polls/tests.py
────────────────────────────────────────────────────────────────────────

import datetime

from django.test import TestCase
from django.utils import timezone
from django.urls import reverse

from .models import Question


# Create your tests here.
class QuestionModelTests(TestCase):
    def test_was_published_recently_with_future_question(self):
        """
        was_published_recently() returns False for questions whose pub_date
        is in the future.
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)
        self.assertIs(future_question.was_published_recently(), False)

    def test_was_published_recently_with_old_quetsion(self):
        """
        was_published_recently() returns False for questions whose pub_date
        is older than 1 day.
        """
        time = timezone.now() - datetime.timedelta(days=1, seconds=1)
        old_question = Question(pub_date=time)
        self.assertIs(old_question.was_published_recently(), False)

    def test_was_published_recently_with_recent_quetsion(self):
        """
        was_published_recently() returns True for questions whose pub_date
        is within the last day.
        """
        time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
        recent_question = Question(pub_date=time)
        self.assertIs(recent_question.was_published_recently(), True)


def create_question(question_text, days):
    """
    Create a question with the given `question_text` and published the
    given number of `days` offset to now (negative for questions published
    in the past, positive for questions that have yet to be published).
    """
    time = timezone.now() - datetime.timedelta(days=days)
    return Question.objects.create(question_text=question_text, pub_date=time)


class QuestionIndexViewTests(TestCase):
    def test_no_questions(self):
        """
        If no questions exist, an appropriate message is displayed.
        """
        response = self.client.get(reverse("polls:index"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "No polls are available.")
        self.assertQuerySetEqual(response.context["latest_question_list"], [])

    def test_past_questions(self):
        """
        Questions with a pub_date in the past are displayed on the
        index page.
        """
        question = create_question(question_text="Past question.", days=-30)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(
            response.context["latest_question_list"],
            [question],
        )

    def test_future_question(self):
        """
        Questions with a pub_date in the future aren't displayed on
        the index page.
        """
        create_question(question_text="Future question.", days=30)
        response = self.client.get(reverse("polls:index"))
        self.assertContains(response, "No polls are available.")
        self.assertQuerySetEqual(response.context["latest_question_list"], [])

    def test_future_question_and_past_question(self):
        """
        Even if both past and future questions exist, only past questions
        are displayed.
        """
        question = create_question(question_text="Past question.", days=-30)
        create_question(question_text="Past question.", days=30)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(
            response.context["latest_question_list"],
            [question],
        )

    def test_past_two_questions(self):
        question1 = create_question("Past question 1", days=-30)
        question2 = create_question("Past question 2", days=-5)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(
            response.context["latest_question_list"],
            [question2, question1],
        )


class QuestionDetailViewTests(TestCase):
    def test_future_question(self):
        """
        The detail view of a question with a pub_date in the future
        returns a 404 not found
        """
        future_question = create_question(question_text="Future question.", days=5)
        url = reverse("polls:detail", args=(future_question.id,))
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_past_question(self):
        """
        The detail view of a question with a pub_date in the past
        displays the question's text.
        """
        past_question = create_question(question_text="Past question.", days=-5)
        url = reverse("polls:detail", args=(past_question.id,))
        response = self.client.get(url)
        self.assertContains(response, past_question.question_text)


════════════════════════════════════════════════════════════════════════
FILE: polls/urls.py
────────────────────────────────────────────────────────────────────────

from django.urls import path

from . import views

app_name = "polls"
urlpatterns = [
    path("", views.IndexView.as_view(), name="index"),
    path("<int:pk>/", views.DetailView.as_view(), name="detail"),
    path("<int:pk>/results/", views.ResultsView.as_view(), name="results"),
    path("<int:question_id>/vote/", views.vote, name="vote"),
]


════════════════════════════════════════════════════════════════════════
FILE: polls/views.py
────────────────────────────────────────────────────────────────────────

from django.db.models import F
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import render, get_object_or_404
from django.urls import reverse
from django.views import generic
from django.utils import timezone

from .models import Choice, Question


# Create your views here.
class IndexView(generic.ListView):
    template_name = "polls/index.html"
    context_object_name = "latest_question_list"

    def get_queryset(self):
        """
        Return the last five published questions (not including those set to be
        published in the future).
        """
        return Question.objects.filter(pub_date__lte=timezone.now()).order_by(
            "-pub_date"
        )[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = "polls/detail.html"

    def get_queryset(self):
        """
        Excludes any questions that aren't published yet.
        """
        return Question.objects.filter(pub_date__lte=timezone.now())


class ResultsView(generic.DetailView):
    model = Question
    template_name = "polls/results.html"


def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST["choice"])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(
            request,
            "polls/detail.html",
            {
                "question": question,
                "error_message": "You didn't select a choice.",
            },
        )
    else:
        selected_choice.votes = F("votes") + 1
        selected_choice.save()
        # Or, more succinctly to reduce the two queries above to just one:
        # selected_choice.update(votes=F("votes") + 1)
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse("polls:results", args=(question.id,)))


════════════════════════════════════════════════════════════════════════
FILE: requirements.txt
────────────────────────────────────────────────────────────────────────

asgiref==3.8.1
black==24.8.0
certifi==2024.7.4
charset-normalizer==3.3.2
click==8.1.7
colorama==0.4.6
cssbeautifier==1.15.1
Django==5.1
django-debug-toolbar==4.4.6
djlint==1.34.1
EditorConfig==0.12.4
html-tag-names==0.1.2
html-void-elements==0.1.0
idna==3.7
jsbeautifier==1.15.1
json5==0.9.25
mypy-extensions==1.0.0
packaging==24.1
pathspec==0.12.1
platformdirs==4.2.2
PyYAML==6.0.2
regex==2023.12.25
requests==2.32.3
six==1.16.0
sqlparse==0.5.1
tomli==2.0.1
tqdm==4.66.5
typing_extensions==4.12.2
urllib3==2.2.2


════════════════════════════════════════════════════════════════════════
FILE: services/__init__.py
────────────────────────────────────────────────────────────────────────

from .api_client import APIClient
from .chat_service import ChatService
from .clan_service import ClanService
from .leaderboard_service import LeaderboardService
from .player_service import PlayerService
from .player_market_service import PlayerMarketService
from .item_service import ItemService
from .task_service import TaskService


════════════════════════════════════════════════════════════════════════
FILE: services/api_client.py
────────────────────────────────────────────────────────────────────────

# Doc = "https://query.idleclans.com/api-docs/index.html"
import requests


class APIClient:
    def __init__(self):
        self.base_url = "https://query.idleclans.com/api"

    def _get_headers(self):
        return {"Content-Type": "application/json"}

    def get(self, endpoint, params=None, headers=None):
        """
        Makes a GET request to the specified URL with optional query parameters and headers.

        Parameters:
            endpoint (str): The URL endpoint to send the GET request to.
            params (dict, optional): Dictionary of query parameters to append to the URL. Default is None.
            headers (dict, optional): Dictionary of headers to include in the request. Default is None.

        Returns:
            response (requests.Response): The response object returned by the GET request.
        """
        print(f"GET: {endpoint} waiting")
        try:
            headers = headers if headers else self._get_headers()
            if headers and not headers["Content-Type"]:
                headers["Content-Type"] = self._get_headers()["Content-Type"]
            response = requests.get(
                f"{self.base_url}/{endpoint}", params=params, headers=headers
            )
            response.raise_for_status()  # Raise an exception for HTTP errors
            print(f"GET: {endpoint} complete")
            if headers and headers["Content-Type"] == "application/json":
                return response.json()
            return response
        except requests.exceptions.HTTPError as http_err:
            print(f"HTTP error occurred: {http_err}")
        except requests.exceptions.RequestException as req_err:
            print(f"Error occurred: {req_err}")
        return None


════════════════════════════════════════════════════════════════════════
FILE: services/chat_service.py
────────────────────────────────────────────────────────────────────────

from services import APIClient


# This class contains all Chat API
# https://query.idleclans.com/api-docs/index.html#tag/Chat
class ChatService:
    def __init__(self, api_client: APIClient):
        self.api_client = api_client
        self.api_class = "Chat"

    def get_chat_recent(
        self,
        general_disabled: bool = False,
        trade_disabled: bool = False,
        help_disabled: bool = False,
        clan_hub_disabled: bool = False,
        combat_lfg_disabled: bool = False,
        raid_lfg_disabled: bool = False,
    ):
        """
        Retrieves the public chat history for various channels.

        Args:
            generalDisabled (bool, optional): If true, excludes the General channel from the result. Defaults to False.
            tradeDisabled (bool, optional): If true, excludes the Trade channel from the result. Defaults to False.
            helpDisabled (bool, optional): If true, excludes the Help channel from the result. Defaults to False.
            clanHubDisabled (bool, optional): If true, excludes the ClanHub channel from the result. Defaults to False.
            combatLFGDisabled (bool, optional): If true, excludes the CombatLFG channel from the result. Defaults to False.
            raidLFGDisabled (bool, optional): If true, excludes the RaidLFG channel from the result. Defaults to False.

        Returns:
            list: A list of chat messages from the selected channels.
        """
        endpoint = f"{self.api_class}/recent"
        params = {
            "generalDisabled": general_disabled,
            "tradeDisabled": trade_disabled,
            "helpDisabled": help_disabled,
            "clanHubDisabled": clan_hub_disabled,
            "combatLFGDisabled": combat_lfg_disabled,
            "raidLFGDisabled": raid_lfg_disabled,
        }
        return self.api_client.get(endpoint, params=params)


════════════════════════════════════════════════════════════════════════
FILE: services/clan_service.py
────────────────────────────────────────────────────────────────────────

from services import APIClient


# This class contains all Clan API
# https://query.idleclans.com/api-docs/index.html#tag/Clan
class ClanService:
    def __init__(self, api_client: APIClient):
        self.api_client = api_client
        self.api_class = "Clan"

    def get_logs_clan(self, name, skip: int = 0, limit: int = 100):
        """
        Retrieves the logs for a specific clan.

        Args:
            name (str): The name of the clan whose logs are to be retrieved.
            skip (int, optional): The number of logs to skip. Defaults to 0.
            limit (int, optional): The maximum number of logs to retrieve. Defaults to 100.

        Returns:
            list: A list of dictionaries, where each dictionary contains:
                - 'clanName': string or null
                - 'memberUsername': string or null
                - 'message': string or null
                - 'timestamp': string (date-time)
        """
        endpoint = f"{self.api_class}/logs/clan/{name}"
        params = {"skip": skip, "limit": limit}
        return self.api_client.get(endpoint, params=params)

    def get_player_logs_within_clan(
        self, clan_name: str, player_name: str, skip: int = 0, limit: int = 100
    ):
        """
        Retrieves the logs for a specific player within a clan.

        Args:
            clanName (str): The name of the clan.
            playerName (str): The name of the player.
            skip (int, optional): The number of logs to skip. Defaults to 0.
            limit (int, optional): The maximum number of logs to retrieve. Defaults to 100.

        Returns:
            list: A list of dictionaries where each dictionary contains:
                - 'clanName': string or null
                - 'memberUsername': string or null
                - 'message': string or null
                - 'timestamp': string (date-time)
        """
        endpoint = f"{self.api_class}/logs/clan/{clan_name}/{player_name}"
        params = {"skip": skip, "limit": limit}
        return self.api_client.get(endpoint, params=params)

    def get_recruitment(self, clan_name: str):
        """
        Retrieves the recruitment information for a specific clan.

        Args:
            clanName (str): The name of the clan.

        Returns:
            dict: A dictionary containing:
                - 'clanName': string or null
                - 'activityScore': float
                - 'minimumTotalLevelRequired': integer
                - 'memberlist': list of objects or null
                - 'memberCount': integer
                - 'isRecruiting': boolean
                - 'language': string or null
                - 'category': string or null
                - 'serializedSkills': string or null
                - 'serializedUpgrades': string or null
                - 'recruitmentMessage': string or null
                - 'houseId': integer

        """

        endpoint = f"{self.api_class}/recruitment/{clan_name}"
        return self.api_client.get(endpoint)

    def get_most_active(self, clan_query_info_json: str = "{}"):
        """
        Retrieves the most active guilds based on the provided query parameters.

        Args:
            clanQueryInfoJson (str, optional): JSON string containing query parameters. Defaults to "{}".

        Returns:
            dict: A dictionary with the following keys and types:
                - 'clanName': string or null
                - 'activityScore': number (float)
                - 'minimumTotalLevelRequired': integer
                - 'memberlist': array of objects or null
                - 'memberCount': integer
                - 'isRecruiting': boolean
                - 'language': string or null
                - 'category': string or null
                - 'serializedSkills': string or null
                - 'serializedUpgrades': string or null
                - 'recruitmentMessage': string or null
                - 'houseId': integer
        """

        endpoint = f"{self.api_class}/most-active"
        params = {"clanQueryInfoJson": clan_query_info_json}
        return self.api_client.get(endpoint, params=params)


════════════════════════════════════════════════════════════════════════
FILE: services/item_service.py
────────────────────────────────────────────────────────────────────────

import json


class ItemService:
    def __init__(self, file_path="data/configData.json"):
        self.data: list[Item] = []
        with open(file_path, "r") as json_file:
            raw_text = json_file.readlines()
            for i, line in enumerate(raw_text):
                if line.strip()[:5] == '"_id"':
                    raw_text.pop(i)
                    # print("stripped invalid json at line:", i)
            data = json.loads("".join(raw_text))
            for item in data["Items"]["Items"]:
                if (
                    not item["CanNotBeTraded"]
                    and not item["Discontinued"]
                    and not item["CanNotBeSoldToGameShop"]
                ):
                    self.data.append(
                        Item(
                            item["ItemId"],
                            item["Name"],
                            item["BaseValue"],
                            item["AssociatedSkill"],
                        )
                    )

    def get_item_by_id(self, id):
        for item in self.data:
            if item.id == id:
                return item


class Item(object):
    def __init__(
        self,
        id,
        name,
        base_value,
        associated_skill,
    ) -> None:
        self.id = id
        self.name = name
        self.base_value = base_value
        self.associated_skill = associated_skill


if __name__ == "__main__":
    item_service = ItemService()
    for item in item_service.data:
        if item.base_value < 10:
            print(item.name, item.base_value)


════════════════════════════════════════════════════════════════════════
FILE: services/leaderboard_service.py
────────────────────────────────────────────────────────────────────────

from services import APIClient


# This class contains all Leaderboard API
# https://query.idleclans.com/api-docs/index.html#tag/Leaderboard
class LeaderboardService:
    def __init__(self, api_client: APIClient):
        self.api_client = api_client
        self.api_class = "Leaderboard"

    def get_clan_logs(self, leader_board_name: str, name: str):
        """
        Fetches the profile of an entity (player or clan) by their name.

        Args:
            leaderboardName (str): Name of the leaderboard, e.g., "players:default" for default game mode or
                                   "players:ironman" for ironman mode.
            name (str): Name of the entity (player or clan) to retrieve the profile for.

        Returns:
            dict: A dictionary containing the profile information of the specified entity.
        """
        endpoint = f"{self.api_class}/profile/{leader_board_name}/{name}"
        return self.api_client.get(endpoint)

    def get_clan_logs(self, leader_board_name: str, name: str):
        """
        Fetches the profile of an entity (player or clan) by their name.

        Args:
            leaderboardName (str): Name of the leaderboard, e.g., "players:default" for default game mode or
                                   "players:ironman" for ironman mode.
            name (str): Name of the entity (player or clan) to retrieve the profile for.

        Returns:
            dict: A dictionary containing the profile information of the specified entity.
        """
        endpoint = f"{self.api_class}/top/{leader_board_name}/{name}"
        return self.api_client.get(endpoint)


════════════════════════════════════════════════════════════════════════
FILE: services/player_market_service.py
────────────────────────────────────────────────────────────────────────

from services import APIClient

import time
import math


# This class contains all PlayerMarket API
# https://query.idleclans.com/api-docs/index.html#tag/PlayerMarket
class PlayerMarketService:
    def __init__(self, api_client: APIClient, priceFetchIntervalLimit=10):
        self.api_client = api_client
        self.api_class = "PlayerMarket"
        self.lastPriceFetch = None
        self.priceFetchIntervalLimit = priceFetchIntervalLimit

    def _fetch_interval_check(self):
        interval_condition = (
            self.lastPriceFetch
            and time.time() - self.lastPriceFetch >= self.priceFetchIntervalLimit
        )
        if interval_condition == False:
            print(
                f"Price fetched no more than {self.priceFetchIntervalLimit} seconds ago.\n"
                f"Try again {self.priceFetchIntervalLimit - math.ceil(time.time() - self.lastPriceFetch)}s later."
            )
            return False
        self.lastPriceFetch = time.time()
        return True

    def get_items_prices_latest(
        self, item_id: int, include_average_price: bool = False
    ):
        """
        Gets the latest prices for a specific item, including the lowest price, highest price,
        and optionally the average price.

        Args:
            itemId (int): The ID of the item to retrieve the latest prices for.
            includeAveragePrice (bool, optional): If true, include the average price of the item from the past 24 hours.
                                                  Defaults to False.

        Returns:
            dict: A dictionary containing the latest price information for the specified item.
        """
        endpoint = f"{self.api_class}/items/prices/latest/{item_id}"
        params = {"includeAveragePrice": include_average_price}
        if self._fetch_interval_check():
            return self.api_client.get(endpoint, params=params)

    def get_items_prices_latest_comprehensive(self, item_id: int):
        """
        Retrieves detailed price information for a specific item.

        This function provides comprehensive price details for a given item, including:
        - The top 10 lowest prices with their corresponding volumes.
        - The top 10 highest prices with their corresponding volumes.
        - The average price of the item over the past 1 day, 7 days, and 30 days.
        - The trade volume of the item over the past 1 day.

        The prices and volumes are based on the current state of the market, with averages
        and trade volume calculated from historical trade records.

        Args:
            itemId (int): The ID of the item to retrieve price details for.

        Returns:
            dict: A dictionary containing detailed price information for the specified item.
        """
        endpoint = f"{self.api_class}/items/prices/latest/comprehensive/{item_id}"
        if self._fetch_interval_check():
            return self.api_client.get(endpoint)

    def get_items_prices_latest(self, include_average_price: bool = False):
        """
        Gets the latest prices for all items, including the lowest price, highest price,
        and optionally the average price.

        Args:
            includeAveragePrice (bool, optional): If true, include the average price of each item from the past 24 hours.
                                                  Defaults to False.

        Returns:
            dict: A dictionary containing the latest prices for all items.
        """
        endpoint = f"{self.api_class}/items/prices/latest"
        params = {"includeAveragePrice": include_average_price}
        if self._fetch_interval_check():
            return self.api_client.get(endpoint, params=params)

    def get_items_prices_history(self, item_id: int, period: str = "1d"):
        """
        Retrieves the price history of a specific item over a given period.

        Args:
            itemId (int): The ID of the item to retrieve the price history for.
            period (str, optional): The period for which to retrieve the price history.
                                    Supported values are '1d', '7d', '30d', and '1y'. Defaults to '1d'.

        Returns:
            dict: A dictionary containing the price history of the specified item for the given period.
        """
        endpoint = f"{self.api_class}/items/prices/history/{item_id}"
        params = {"period": period}
        if self._fetch_interval_check():
            return self.api_client.get(endpoint, params=params)

    def get_items_prices_history_value(self, period: str = "1d", limit: int = 10):
        """
        Retrieves the trades with the highest item prices within a specified period.

        Args:
            period (str, optional): The period for which to retrieve the most valuable trades.
                                    Supported values are '1d', '7d', '30d', and '1y'. Defaults to '1d'.
            limit (int, optional): The maximum number of records to retrieve, between 1 and 10. Defaults to 10.

        Returns:
            list: A list of trades with the highest item prices for the specified period.
        """
        endpoint = f"{self.api_class}/items/prices/history/value"
        params = {"period": period, "limit": limit}
        if self._fetch_interval_check():
            return self.api_client.get(endpoint, params=params)

    def get_items_volume_history(self, period: str = "1d", limit: int = 10):
        """
        Retrieves the top items by trade volume within a specified period.

        Args:
            period (str, optional): The period for which to retrieve the top items by volume. Supported values
                are '1d' (1 day), '7d' (7 days), '30d' (30 days), and '1y' (1 year). Defaults to '1d'.
            limit (int, optional): The maximum number of records to retrieve, between 1 and 10. Defaults to 10.

        Returns:
            list: A list of dictionaries, each representing an item with high trade volume. Each dictionary
            includes:
                - 'item_id' (int): The ID of the item.
                - 'volume' (int): The total trade volume of the item.
                - 'timestamp' (str): The timestamp representing the end of the period for the volume calculation.
        """
        endpoint = f"{self.api_class}/items/volume/history"
        params = {"period": period, "limit": limit}
        if self._fetch_interval_check():
            return self.api_client.get(endpoint, params=params)


════════════════════════════════════════════════════════════════════════
FILE: services/player_service.py
────────────────────────────────────────────────────────────────────────

from services import APIClient


# This class contains all Player API
# https://query.idleclans.com/api-docs/index.html#tag/Player
class PlayerService:
    def __init__(self, api_client: APIClient):
        self.api_client = api_client
        self.api_class = "Player"

    def get_clan_logs(self, name: str, skip: int = 0, limit: int = 100):
        """
        Retrieves the logs for a specific player from all clans.

        Args:
            name (str): The name of the player to retrieve logs for.
            skip (int, optional): The number of logs to skip. Defaults to 0.
            limit (int, optional): The maximum number of logs to retrieve. Defaults to 100.

        Returns:
            list: A list of dictionaries, each containing:
                - 'clanName': string or null
                - 'memberUsername': string or null
                - 'message': string or null
                - 'timestamp': string (date-time)
        """
        endpoint = f"{self.api_class}/clan-logs/{name}"
        params = {"skip": skip, "limit": limit}
        return self.api_client.get(endpoint, params=params)

    def get_profile(self, name: str):
        """
        Retrieves the profile for a specific player.

        Args:
            name (str): The name of the player to retrieve the profile for.

        Returns:
            dict: A dictionary with the following keys and types:
                - 'username': string or null
                - 'gameMode': string or null
                - 'guildName': string or null
                - 'skillExperiences': object or null
                - 'equipment': object or null
                - 'enchantmentBoosts': object or null
                - 'upgrades': object or null
                - 'griffinKills': integer
                - 'devilKills': integer
                - 'hadesKills': integer
                - 'zeusKills': integer
                - 'medusaKills': integer
                - 'chimeraKills': integer
                - 'kronosKills': integer
                - 'reckoningOfTheGodsCompletions': integer
                - 'guardiansOfTheCitadelCompletions': integer
        """
        endpoint = f"{self.api_class}/profile/{name}"
        return self.api_client.get(endpoint)

    def get_profile_simple(self, name):
        """
        Retrieves a simple profile for a specific player.

        Args:
            username (str): The username of the player to retrieve the simple profile for.

        Returns:
            dict: A dictionary with the following keys and types:
                - 'skillExperiences': string or null
                - 'equipment': string or null
                - 'hoursOffline': number (double)
                - 'taskTypeOnLogout': integer
                - 'taskNameOnLogout': string or null
        """
        endpoint = f"{self.api_class}/profile/simple/{name}"
        return self.api_client.get(endpoint)


════════════════════════════════════════════════════════════════════════
FILE: services/task_service.py
────────────────────────────────────────────────────────────────────────

import json

from services import ItemService
from services.item_service import Item


class TaskService:
    def __init__(self, item_service: ItemService, file_path="data/configData.json"):
        self.categories: list[TaskCategory] = []

        with open(file_path, "r") as json_file:
            raw_text = json_file.readlines()
            for i, line in enumerate(raw_text):
                if line.strip()[:5] == '"_id"':
                    raw_text.pop(i)
                    # print("stripped invalid json at line:", i)
            data = json.loads("".join(raw_text))

            self.categories = [
                TaskCategory(
                    id=task["Tasks"][0]["Items"][0]["TaskId"],
                    skill_id=task["Tasks"][0]["Items"][0]["Skill"],
                    name=task["Key"],
                    tasks=[
                        TaskItem(
                            name=task_item["Name"],
                            item_reward=(
                                item_service.get_item_by_id(task_item["ItemReward"])
                                if task_item["ItemReward"] != -1
                                else None
                            ),
                            level_requirement=task_item["LevelRequirement"],
                            base_time=task_item["BaseTime"],
                            exp_reward=task_item["ExpReward"],
                            item_amount=task_item["ItemAmount"],
                            costs=[
                                TaskCost(
                                    item=item_service.get_item_by_id(cost["Item"]),
                                    amount=cost["Amount"],
                                )
                                for cost in task_item["Costs"] or []
                            ],
                        )
                        for task_item in task["Tasks"][0]["Items"]
                    ],
                )
                for task in data["Tasks"]
            ]

    def get_tasks(self):
        return self.categories


class TaskCost:
    def __init__(
        self,
        item: Item,
        amount: int,
    ) -> None:
        self.item = item
        self.amount = amount


class TaskItem:
    def __init__(
        self,
        name: str = None,
        item_reward: Item = None,
        level_requirement: float = None,
        base_time: float = None,
        exp_reward: float = None,
        item_amount: int = None,
        costs=None,
    ) -> None:
        self.name = name
        self.item_reward = item_reward
        self.level_requirement = level_requirement
        self.base_time = base_time
        self.exp_reward = exp_reward
        self.item_amount = item_amount
        self.costs = costs
        gold_efficiency = None
        xp_efficiency = None
        gold_efficiency_calculation_time = None
        xp_efficiency_calculation_time = None
        sold_as_base_price = False


class TaskCategory:
    def __init__(
        self,
        id: int = None,
        skill_id: int = None,
        name="",
        tasks: list[TaskItem] = [],
    ) -> None:
        self.id = id
        self.skill_id = skill_id
        self.name = name
        self.tasks = tasks


════════════════════════════════════════════════════════════════════════
FILE: utils/__init__.py
────────────────────────────────────────────────────────────────────────

from .ascii_ui import AsciiUI


════════════════════════════════════════════════════════════════════════
FILE: utils/ascii_ui.py
────────────────────────────────────────────────────────────────────────

class AsciiUI:
    def __init__(self):
        self.width = 40

    def _generate_menu(self, title: str, options: list, display_exit=False):
        menu = []
        if len(options) > 9:
            # currently uses str comp :+13
            raise NotImplementedError
        padding = (self.width - len(title)) // 2
        border = "=" * self.width

        menu.append(border)
        menu.append(" " * padding + title + " " * padding)
        menu.append(border)
        for i, option in enumerate(options):
            menu.append(f"{i+1}: {option}")
        menu.append(f"0: {'Exit' if display_exit else 'back'}")
        menu.append(border)
        return "\n".join(menu)

    def menu(self):
        """
        options:\n
        1: Calculate Gold Efficiency\n
        2: Market Search\n
        3: Reload Data\n
        4: Settings\n
        """
        return self._generate_menu(
            "Idle Clans Menu",
            ["Calculate Gold Efficiency", "Market Search", "Reload Data", "Settings"],
            display_exit=True,
        )

    def reload_data(self):
        """
        options:\n
        1: Reload Items Data\n
        2: Reload Player Data\n
        3: Auto Reload Settings\n
        """
        self._generate_menu(
            "Reload Data",
            ["Reload Items Data", "Reload Player Data", "Auto Reload Settings"],
        )

    def calculate_gold_efficiency(self):
        """
        options:\n
        1: Global\n
        2: Player bound\n
        """
        self._generate_menu(
            "Calculate Gold Efficiency",
            ["Global", "Player bound"],
        )

    def settings(self):
        """
        options:\n
        1: Global\n
        2: Player bound\n
        """
        self._generate_menu(
            "Settings",
            ["Global", "Player bound"],
        )


════════════════════════════════════════════════════════════════════════
FILE: utils/util.py
────────────────────────────────────────────────────────────────────────

# import json
# def fetch_all_items(filepath_to_config_data=DATA_PATH):
#     # Path: \AppData\LocalLow\isam_games\Idle Clans\Production\configData.json
#     # The configdata file of IC contains all information, we simply fetch on update when needed
#     with open(filepath_to_config_data, "r") as json_file:
#         return json.load(json_file)


def calculate_max_hit(stat: int, level: int, weakness_match: bool = False) -> int:
    if weakness_match:
        return int((stat / 8 + level + 13 + stat * level / 64) / 10 * 1.2)
    return int((stat / 8 + level + 13 + stat * level / 64) / 10)


def calculate_augmented_stats(stat: int, level: int) -> int:
    return int((stat + 64) * (level + 8) / 10)


def calculate_hit_chance(
    accuracy: int,
    level: int,
    target_defence: int,
    target_level: int,
    weakness_match: bool = False,
) -> int:
    ACC = calculate_augmented_stats(accuracy, level)
    DEF = calculate_augmented_stats(target_defence, target_level)
    if weakness_match:
        DEF *= 0.8

    if ACC < DEF:
        return int(((ACC - 1) / (2 * DEF)) * 100)
    return int((1 - (DEF + 1) / (2 * ACC)) * 100)


if __name__ == "__main__":
    STR_STAT = 71 + 14
    ACC_STAT = 76
    DEF_STAT = 221
    STR_LVL = 69
    ACC_LVL = 55
    DEF_LVL = 58
    weakness_match = True
    TARGET_STR_STAT = 0
    TARGET_ACC_STAT = 0
    TARGET_DEF_STAT = 0
    TARGET_STR_LEVEL = 0
    TARGET_ACC_LEVEL = 0
    TARGET_DEF_LEVEL = 0
    print("Yours:")
    print(
        f"Hit Chance = {calculate_hit_chance(ACC_STAT, ACC_LVL, TARGET_DEF_STAT, TARGET_DEF_LEVEL, weakness_match)}"
    )
    print("Max hit = %s" % calculate_max_hit(STR_STAT, STR_LVL, weakness_match))
    print("Enemy:")
    print(
        f"Hit Chance = {calculate_hit_chance(TARGET_ACC_STAT, TARGET_ACC_LEVEL, DEF_STAT, DEF_LVL)}"
    )
    print("Max hit = %s" % calculate_max_hit(TARGET_STR_STAT, TARGET_ACC_LEVEL))


════════════════════════════════════════════════════════════════════════
FILE: utils/xp.py
────────────────────────────────────────────────────────────────────────

import json


class XP:
    def __init__(self, file_path="data/xp_table.json") -> None:
        self.table = []
        with open(file_path, "r") as json_file:
            data = json.load(json_file)
            for lvl in data.values():
                self.table.append(lvl["xp"])

    def xp_to_level(self, xp: float) -> int:
        if xp < 0:
            # todo: Throw Error
            print("INVALID XP:", xp)
            return -1
        num_levels = len(self.table)
        for lvl in range(num_levels):
            if xp < self.table[lvl]:
                return lvl
        return num_levels

    def level_to_xp(self, level: float) -> int:
        if 1 > level or level > len(self.table):
            # todo: Throw Error
            print("INVALID LEVEL:", level)
            return -1
        return self.table[level - 1]

════════════════════════════════════════════════════════════════════════
                         END OF SUMMARY
════════════════════════════════════════════════════════════════════════
